snippet anaf
	accepts_nested_attributes_for :${1:model}

snippet artnpp
	assert_redirected_to ${1:parent}_${2:child}_path(${3:@parent})

snippet artnp
	assert_redirected_to ${1:parent}_${2:child}_path(${0:@parent}, ${0:@child})

snippet artpp
	assert_redirected_to ${0:model}s_path

snippet artp
	assert_redirected_to ${1:model}_path(${2:@model})

snippet art
	assert_redirected_to ${1::action => "${2:index}"}

snippet asd
	assert_difference "${1:Model}.${2:count}", $1 do
	       ${3}
	end

snippet asnd
	assert_no_difference "${1:Model}.${2:count}" do
	       ${3}
	end

snippet asre
	assert_response :${1:success}, @response.body${2}

snippet ass
	assert_select "${1:path}", :${2:text}

snippet bf
	before_filter :${1:method}

snippet bt
	belongs_to :${1:association}

snippet crw
	cattr_accessor :${1:attr_names}

snippet defcreate
	def create
		@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])

		respond_to do |wants|
			if @$1.save
				flash[:notice] = "$2 was successfully created."
				wants.html { redirect_to(@$1) }
				wants.xml  { render :xml => @$1, :status => :created, :location => @$1 }
			else
				wants.html { render :action => "new" }
				wants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
			end
		end
	end${3}

snippet defdestroy
	def destroy
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
		@$1.destroy

		respond_to do |wants|
			wants.html { redirect_to($1s_url) }
			wants.xml  { head :ok }
		end
	end${3}

snippet defedit
	def edit
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	end

snippet defindex
	def index
		@${1:model_class_name} = ${2:ModelClassName}.all

		respond_to do |wants|
			wants.html # index.html.erb
			wants.xml  { render :xml => @$1s }
		end
	end${3}

snippet defnew
	def new
		@${1:model_class_name} = ${2:ModelClassName}.new

		respond_to do |wants|
			wants.html # new.html.erb
			wants.xml  { render :xml => @$1 }
		end
	end${3}

snippet defshow
	def show
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |wants|
			wants.html # show.html.erb
			wants.xml  { render :xml => @$1 }
		end
	end${3}

snippet defupdate
	def update
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |wants|
			if @$1.update_attributes(params[:$1])
				flash[:notice] = "$2 was successfully updated."
				wants.html { redirect_to(@$1) }
				wants.xml  { head :ok }
			else
				wants.html { render :action => "edit" }
				wants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
			end
		end
	end${3}

snippet flash
	flash[:${1:notice}] = "${2}"

snippet habtm
	has_and_belongs_to_many :${1:object}, :join_table => "${2:table_name}", :foreign_key => "${3}_id"${4}

snippet hmd
	has_many :${1:object}s, :class_name => "${2:object}", :foreign_key => "${3:reference}_id", :dependent => :destroy

snippet hm
	has_many :${1:object}s, :class_name => "${2:object}"

snippet hmt
	has_many :${1:association_name}, :through => :${1:join_association}

snippet ho
	has_one :${1:object}, :class_name => "${2:Class}", :foreign_key => "${3:class}_id"

snippet i18
	I18n.t("${1:type.key}")${2}

snippet logd
	logger.debug { "${1:message}" }${2}

snippet loge
	logger.error { "${1:message}" }${2}

snippet logf
	logger.fatal { "${1:message}" }${2}

snippet logi
	logger.info { "${1:message}" }${2}

snippet logw
	logger.warn { "${1:message}" }${2}

snippet mac
	add_column :${1:table}, :${2:column}, :${3:type}

snippet mapca
	${1:map}.catch_all "*${2:anything}", :controller => "${3:default}", :action => "${4:error}"${5}

snippet mapc
	${1:map}.${2:connect} "${3:controller/:action/:id}"

snippet mapr
	${1:map}.resource :${2:resource}

snippet maprs
	${1:map}.resources :${2:resource}

snippet mapwo
	${1:map}.with_options :${2:controller} => "${3:thing}" do |$3|
	        ${4}
	end

snippet mbs
	before_save :${1:method}

snippet mccc
	t.column :${1:title}, :${2:string}

snippet mcc
	change_column :${1:table}, :${2:column}, :${3:type}

snippet mcht
	change_table :${1:table_name} do |t|
	        ${2}
	end

snippet mcol
	remove_column :${1:table}, :${2:column}

snippet mct
	create_table :${1:table_name} do |t|
	        t.column :${2:name}, :${3:type}
	end

snippet migration
	class ${1:`Snippet_MigrationNameFromFilename()`} < ActiveRecord::Migration
	 	def self.up
	 		${2}
	 	end

	 	def self.down
	 	end
	end

snippet mp
	map(&:${1:id})

snippet mrw
	mattr_accessor :${1:attr_names}

snippet scopel
	scope :${1:name}, lambda { |${2:param}| { :conditions => ["${3:field} = ?", ${4:param}] }}

snippet scope
	scope :${1:name}, :conditions => ["${2:field} = ?", ${3:true}]

snippet pa
	params[:${1:id}]${2}

snippet ra
	render :action => "${1:action}"

snippet rest
	respond_to do |wants|
	  wants.${1:html} { ${2} }
	end

snippet rjson
	render :json => ${1:text to render}

snippet rp
	render :partial => "${1:item}"

snippet rt
	render :text => "${1:text to render}"

snippet rxml
	render :xml => ${1:text to render}

snippet sha1
	Digest::SHA1.hexdigest(${1:string})

snippet tcbi
	t.binary :${1:title}, :limit => ${2:2}.megabytes
	${3}

snippet tcb
	t.boolean :${1:title}
	${2}

snippet tcda
	t.date :${1:title}
	${2}

snippet tcd
	t.decimal :${1:title}
	${4}

snippet tcdt
	t.datetime :${1:title}
	${2}

snippet tcf
	t.float :${1:title}
	${2}

snippet tch
	t.change :${1:name}, :${2:string}, :${3:limit} => ${4:80}
	${5}

snippet tci
	t.integer :${1:title}
	${2}

snippet tcl
	t.integer :lock_version, :null => false, :default => 0
	${1}

snippet tcs
	t.string :${1:title}
	${2}

snippet tcti
	t.time :${1:title}
	${2}

snippet tct
	t.text :${1:title}
	${2}

snippet tcts
	t.timestamp :${1:title}
	${2}

snippet tctss
	t.timestamps
	${1}

snippet trc
	t.remove :${1:column}

snippet tref
	t.references :${1:model}

snippet tre
	t.rename :${1:old_column_name}, :${1:new_column_name}
	${1:}

snippet vao
	validates_acceptance_of :${1:terms}, :accept => "${2}", :message => "${3:terms_message}"

snippet va
	validates_associated :${1:attribute}, :on => :${2:create}

snippet vc
	validates_confirmation_of :${1:attribute}, :on => :${2:create}, :message => "${3:should match confirmation}"

snippet ve
	validates_exclusion_of :${1:attribute}, :in => %w( mov avi ), :on => :${2:create}, :message => "${3:extension %s is not allowed}"

snippet vf
	validates_format_of :${1:attribute}, :with => /${2:regex}/, :on => :${3:create}, :message => "${4:is invalid}"

snippet vi
	validates_inclusion_of :${1:attribute}, :in => %w( mov avi ), :on => :${2:create}, :message => "${3:extension %s is not included in the list}"

snippet vl
	validates_length_of :${1:attribute}, :within => 3..20, :on => :${2:create}, :message => "${3:must be present}"

snippet vn
	validates_numericality_of :${1:attribute}, :on => :${2:create}, :message => "${3:is not a number}"

snippet vpo
	validates_presence_of :${1:attribute}

snippet vu
	validates_uniqueness_of :${1:attribute}, :on => :${2:create}, :message => "${3:must be unique}"
